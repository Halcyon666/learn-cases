= Functional Registry Documentation
Author: Project Team
:icons: font
:toc:
:toclevels: 2

== Overview

The `com.whalefall.learncases.design.functionalregistry` package provides a framework for registering and executing jobs using templates. Each job is associated with a specific template, which handles the execution flow and delegates the actual business logic to the job.

== Core Concepts and Components

=== RegisterExecuteEngine
- **Responsibility**: Manages the registration of jobs and their associated templates. Jobs are stored in a `Map` with the job name as the key and the template component as the value.
- **Key Features**:
  - Generic implementation to support various data types.
  - Provides a `run` method to execute registered jobs.

=== Template
- **Responsibility**: Defines the execution flow for jobs. Templates handle pre- and post-processing and delegate the core business logic to the job.
- **Implementations**:
  - `TemplateImpl1`: Handles `TxData` objects.
  - `TemplateImpl2`: Handles `Map<String, Object>`.

=== Job
- **Responsibility**: Represents the actual business logic to be executed.
- **Implementations**:
  - `Job1`: Processes `TxData` objects.
  - `Job2`: Processes `Map<String, Object>`.

== Usage Examples

=== Example 1: Registering Jobs and Templates

[source,java]
----
include::service/Job.java[]
----

[source,java]
----
include::template/Template.java[]
----

[source,java]
----
include::RegisterExecuteEngine.java[]
----

=== Example 2: Implementing Templates

[source,java]
----
@Component("templateImpl1")
@Slf4j
public class TemplateImpl1 implements Template<TxData> {
    @Override
    public TxData handler(Supplier<TxData> businessFunction) {
        log.info("Executing TemplateImpl1");
        return businessFunction.get();
    }
}

@Component("templateImpl2")
@Slf4j
public class TemplateImpl2 implements Template<Map<String, Object>> {
    @Override
    public Map<String, Object> handler(Supplier<Map<String, Object>> businessFunction) {
        log.info("Executing TemplateImpl2");
        return businessFunction.get();
    }
}
----

=== Example 3: Implementing Jobs

[source,java]
----
@Service
@Slf4j
public class Job1 implements Job<TxData> {
    @Override
    public TxData doJob(TxData txData) {
        log.info("Executing Job1");
        return txData;
    }
}

@Service
@Slf4j
public class Job2 implements Job<Map<String, Object>> {
    @Override
    public Map<String, Object> doJob(Map<String, Object> data) {
        log.info("Executing Job2");
        return data;
    }
}
----

=== Example 4: Exposing Job Execution via REST

[source,java]
----
@RestController
@RequestMapping("/run")
public class RunJobController {

    private final RegisterExecuteEngine<TxData> engine;

    public RunJobController(RegisterExecuteEngine<TxData> engine) {
        this.engine = engine;
    }

    @PostMapping("/{jobName}")
    public TxData execute(@PathVariable String jobName, @RequestBody TxData params) {
        return engine.run(jobName, () -> params);
    }
}
----

== Best Practices

- Ensure that job names are unique to avoid overwriting existing jobs.
- Validate input parameters before executing jobs to prevent runtime errors.
- Use meaningful job names to improve maintainability and readability.

== Conclusion

This document provides an overview of the `com.whalefall.learncases.design.functionalregistry` package, its design goals, and usage examples. For detailed API documentation, refer to the code comments and additional resources.
