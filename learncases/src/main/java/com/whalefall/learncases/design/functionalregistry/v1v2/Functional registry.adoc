= Functional Registry Documentation
Author: Project Team
:icons: font
:toc:
:toclevels: 2

== Overview

The `com.whalefall.learncases.design.functionalregistry` package provides a framework for registering and executing Businesss using templates. Each Business is associated with a specific template, which handles the execution flow and delegates the actual business logic to the Business.

== Core Concepts and Components

=== RegisterExecuteEngine
- **Responsibility**: Manages the registration of Businesss and their associated templates. Businesss are stored in a `Map` with the Business name as the key and the template component as the value.
- **Key Features**:
  - Generic implementation to support various data types.
  - Provides a `run` method to execute registered Businesss.

=== Template
- **Responsibility**: Defines the execution flow for Businesss. Templates handle pre- and post-processing and delegate the core business logic to the Business.
- **Implementations**:
  - `TemplateImpl1`: Handles `BusinessDto1` objects.
  - `TemplateImpl2`: Handles `Map<String, Object>`.

=== Business
- **Responsibility**: Represents the actual business logic to be executed.
- **Implementations**:
  - `Business1`: Processes `BusinessDto1` objects.
  - `Business2`: Processes `Map<String, Object>`.

== Usage Examples

=== Example 1: Registering Businesss and Templates

[source,java]
----
include::service/Business.java[]
----

[source,java]
----
include::template/Template.java[]
----

[source,java]
----
include::RegisterEnginV1.java[]
----

=== Example 2: Implementing Templates

[source,java]
----
@Component("templateImpl1")
@Slf4j
public class TemplateImpl1 implements Template<TxData> {
    @Override
    public TxData handler(Supplier<TxData> businessFunction) {
        log.info("Executing TemplateImpl1");
        return businessFunction.get();
    }
}

@Component("templateImpl2")
@Slf4j
public class TemplateImpl2 implements Template<Map<String, Object>> {
    @Override
    public Map<String, Object> handler(Supplier<Map<String, Object>> businessFunction) {
        log.info("Executing TemplateImpl2");
        return businessFunction.get();
    }
}
----

=== Example 3: Implementing Businesss

[source,java]
----
@Service
@Slf4j
public class Business1 implements Business<TxData> {
    @Override
    public TxData doBusiness(TxData txData) {
        log.info("Executing Business1");
        return txData;
    }
}

@Service
@Slf4j
public class Business2 implements Business<Map<String, Object>> {
    @Override
    public Map<String, Object> doBusiness(Map<String, Object> data) {
        log.info("Executing Business2");
        return data;
    }
}
----

=== Example 4: Exposing Business Execution via REST

[source,java]
----
@RestController
@RequestMapping("/run")
public class RunBusinessController {

    private final RegisterExecuteEngine<TxData> engine;

    public RunBusinessController(RegisterExecuteEngine<TxData> engine) {
        this.engine = engine;
    }

    @PostMapping("/{BusinessName}")
    public TxData execute(@PathVariable String BusinessName, @RequestBody TxData params) {
        return engine.run(BusinessName, () -> params);
    }
}
----

== Best Practices

- Ensure that Business names are unique to avoid overwriting existing Businesss.
- Validate input parameters before executing Businesss to prevent runtime errors.
- Use meaningful Business names to improve maintainability and readability.

== Conclusion

This document provides an overview of the `com.whalefall.learncases.design.functionalregistry` package, its design goals, and usage examples. For detailed API documentation, refer to the code comments and additional resources.
